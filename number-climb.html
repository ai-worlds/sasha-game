<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Number Climb</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #0a0a0f;
            font-family: 'Courier New', monospace;
            color: #aab;
            overflow: hidden;
            touch-action: manipulation;
            user-select: none;
        }
        
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            pointer-events: none;
        }
        
        #topBar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(10, 10, 20, 0.85);
            border-bottom: 1px solid #223;
            pointer-events: auto;
        }
        
        #stats {
            font-size: 12px;
            color: #889;
        }
        
        #menuBtn {
            background: rgba(40, 40, 60, 0.8);
            border: 1px solid #445;
            color: #aab;
            padding: 8px 16px;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        #menuBtn:hover {
            background: rgba(60, 60, 80, 0.9);
        }
        
        #problemArea {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            pointer-events: auto;
        }
        
        #problem {
            font-size: clamp(28px, 8vw, 48px);
            color: #eef;
            text-shadow: 0 0 20px rgba(150, 180, 255, 0.5);
            margin-bottom: 30px;
            text-align: center;
            background: rgba(10, 10, 20, 0.9);
            padding: 20px 40px;
            border-radius: 12px;
            border: 2px solid #334;
        }
        
        #answers {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 12px;
            max-width: 500px;
            width: 100%;
        }
        
        .answer-btn {
            background: rgba(30, 30, 50, 0.9);
            border: 2px solid #445;
            color: #dde;
            font-family: inherit;
            font-size: clamp(20px, 5vw, 28px);
            padding: 20px 10px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.15s;
        }
        
        .answer-btn:hover {
            background: rgba(50, 50, 80, 0.95);
            border-color: #667;
        }
        
        .answer-btn:active {
            transform: scale(0.95);
        }
        
        .answer-btn.correct {
            background: rgba(40, 120, 60, 0.9);
            border-color: #4a8;
        }
        
        .answer-btn.wrong {
            background: rgba(120, 40, 40, 0.9);
            border-color: #a44;
        }
        
        #feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            z-index: 20;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 10, 0.95);
            z-index: 100;
            display: none;
            overflow-y: auto;
        }
        
        #menu.visible {
            display: block;
        }
        
        #menuContent {
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
        }
        
        #menu h2 {
            color: #aac;
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
            letter-spacing: 3px;
        }
        
        .menu-section {
            background: rgba(20, 20, 35, 0.8);
            border: 1px solid #334;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .menu-section h3 {
            color: #889;
            font-size: 14px;
            margin-bottom: 12px;
            letter-spacing: 2px;
        }
        
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #223;
        }
        
        .toggle-row:last-child {
            border-bottom: none;
        }
        
        .toggle-row label {
            color: #bbc;
            font-size: 16px;
        }
        
        .toggle {
            width: 50px;
            height: 28px;
            background: #333;
            border-radius: 14px;
            position: relative;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .toggle.on {
            background: #486;
        }
        
        .toggle::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: #ddd;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: left 0.2s;
        }
        
        .toggle.on::after {
            left: 25px;
        }
        
        .menu-btn {
            width: 100%;
            background: rgba(40, 40, 60, 0.8);
            border: 1px solid #445;
            color: #aab;
            padding: 12px;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            border-radius: 6px;
            margin-top: 10px;
        }
        
        .menu-btn:hover {
            background: rgba(60, 60, 80, 0.9);
        }
        
        .menu-btn.danger {
            border-color: #644;
            color: #c99;
        }
        
        .menu-btn.danger:hover {
            background: rgba(80, 40, 40, 0.9);
        }
        
        #hardestList {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .hard-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #223;
            font-size: 13px;
        }
        
        .hard-item .problem-text {
            color: #bbc;
        }
        
        .hard-item .stats-text {
            color: #778;
        }
        
        .slider-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
        }
        
        .slider-row input[type="range"] {
            width: 120px;
        }
        
        .slider-value {
            color: #8af;
            min-width: 30px;
            text-align: right;
        }
        
        #modeToggle {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 12px;
            background: rgba(30, 30, 50, 0.8);
            border: 1px solid #445;
            color: #889;
            font-family: inherit;
            font-size: 13px;
            cursor: pointer;
            border-radius: 6px;
        }
        
        .mode-btn.active {
            background: rgba(60, 80, 100, 0.9);
            border-color: #68a;
            color: #bdf;
        }
        
        #closeMenu {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(60, 40, 40, 0.8);
            border: 1px solid #644;
            color: #c99;
            width: 40px;
            height: 40px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 50%;
            z-index: 101;
        }
        
        #victoryScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 20, 30, 0.95);
            z-index: 200;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        
        #victoryScreen.visible {
            display: flex;
        }
        
        #victoryScreen h1 {
            font-size: 36px;
            color: #8cf;
            letter-spacing: 5px;
            margin-bottom: 20px;
        }
        
        #victoryScreen p {
            color: #889;
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="topBar">
            <div id="stats">
                <div>Height: <span id="heightDisplay">0</span> / 1000</div>
                <div>Streak: <span id="streakDisplay">0</span> | Nerf: <span id="nerfDisplay">0</span>%</div>
            </div>
            <button id="menuBtn">☰ Menu</button>
        </div>
        
        <div id="problemArea">
            <div id="problem">7 × 8 = ?</div>
            <div id="answers"></div>
        </div>
    </div>
    
    <div id="feedback"></div>
    
    <div id="menu">
        <button id="closeMenu">×</button>
        <div id="menuContent">
            <h2>NUMBER CLIMB</h2>
            
            <div class="menu-section">
                <h3>OPERATIONS</h3>
                <div class="toggle-row">
                    <label>Addition (+)</label>
                    <div class="toggle on" data-op="add"></div>
                </div>
                <div class="toggle-row">
                    <label>Subtraction (−)</label>
                    <div class="toggle on" data-op="sub"></div>
                </div>
                <div class="toggle-row">
                    <label>Multiplication (×)</label>
                    <div class="toggle on" data-op="mul"></div>
                </div>
                <div class="toggle-row">
                    <label>Division (÷)</label>
                    <div class="toggle on" data-op="div"></div>
                </div>
            </div>
            
            <div class="menu-section">
                <h3>GAME MODE</h3>
                <div id="modeToggle">
                    <button class="mode-btn active" data-mode="answer">Answer Mode</button>
                    <button class="mode-btn" data-mode="question">Question Mode</button>
                </div>
            </div>
            
            <div class="menu-section">
                <h3>OPTIONS</h3>
                <div class="slider-row">
                    <label>Answer Choices</label>
                    <input type="range" id="choicesSlider" min="4" max="8" value="6">
                    <span class="slider-value" id="choicesValue">6</span>
                </div>
            </div>
            
            <div class="menu-section">
                <h3>TOP 20 HARDEST</h3>
                <div id="hardestList"></div>
            </div>
            
            <div class="menu-section">
                <h3>PROGRESS</h3>
                <div id="progressStats"></div>
                <button class="menu-btn danger" id="resetBtn">Reset All Progress</button>
            </div>
            
            <button class="menu-btn" id="resumeBtn">Resume Game</button>
        </div>
    </div>
    
    <div id="victoryScreen">
        <h1>ASCENSION COMPLETE</h1>
        <p>You've conquered the Number Climb.</p>
        <p id="victoryStats"></p>
        <button class="menu-btn" id="playAgainBtn">Climb Again</button>
    </div>

    <script>
        // ========== CONFIGURATION ==========
        const CONFIG = {
            GOAL_HEIGHT: 1000,
            BASE_FALL_PERCENT: 100,
            NERF_PER_FALL: 1,
        };

        // ========== CANVAS SETUP ==========
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ========== GAME STATE ==========
        let state = {
            height: 0,
            targetHeight: 0,
            streak: 0,
            nerfLevel: 0,
            totalCorrect: 0,
            totalWrong: 0,
            operations: { add: true, sub: true, mul: true, div: true },
            mode: 'answer',
            numChoices: 6,
            problems: {}, // key: "a op b" -> { correct: 0, wrong: 0, totalTime: 0, attempts: 0 }
            currentProblem: null,
            problemStartTime: 0,
            gameWon: false,
            characterY: 0,
            platforms: [],
            particles: [],
            stars: [],
        };

        // ========== STORAGE ==========
        function saveState() {
            const saveData = {
                height: state.height,
                nerfLevel: state.nerfLevel,
                totalCorrect: state.totalCorrect,
                totalWrong: state.totalWrong,
                operations: state.operations,
                mode: state.mode,
                numChoices: state.numChoices,
                problems: state.problems,
                gameWon: state.gameWon,
            };
            localStorage.setItem('numberClimb', JSON.stringify(saveData));
        }
        
        function loadState() {
            const saved = localStorage.getItem('numberClimb');
            if (saved) {
                const data = JSON.parse(saved);
                Object.assign(state, data);
                state.targetHeight = state.height;
            }
            generateStars();
            generatePlatforms();
        }
        
        function resetProgress() {
            if (confirm('Reset all progress? This cannot be undone.')) {
                localStorage.removeItem('numberClimb');
                state = {
                    height: 0,
                    targetHeight: 0,
                    streak: 0,
                    nerfLevel: 0,
                    totalCorrect: 0,
                    totalWrong: 0,
                    operations: { add: true, sub: true, mul: true, div: true },
                    mode: 'answer',
                    numChoices: 6,
                    problems: {},
                    currentProblem: null,
                    problemStartTime: 0,
                    gameWon: false,
                    characterY: 0,
                    platforms: [],
                    particles: [],
                    stars: [],
                };
                generateStars();
                generatePlatforms();
                updateMenuUI();
                generateProblem();
                closeMenu();
            }
        }

        // ========== PROBLEM GENERATION ==========
        function getProblemDifficulty(key) {
            const p = state.problems[key];
            if (!p || p.attempts === 0) return 0.5; // Unknown = medium priority
            
            const avgTime = p.totalTime / p.attempts;
            const errorRate = p.wrong / p.attempts;
            
            // Higher score = harder = show more often
            return (avgTime / 5000) + (errorRate * 2);
        }
        
        function generateAllProblems() {
            const problems = [];
            
            if (state.operations.add) {
                for (let a = 1; a <= 12; a++) {
                    for (let b = 1; b <= 12; b++) {
                        problems.push({ a, b, op: 'add', answer: a + b, display: `${a} + ${b}` });
                    }
                }
            }
            
            if (state.operations.sub) {
                for (let a = 2; a <= 20; a++) {
                    for (let b = 1; b < a; b++) {
                        problems.push({ a, b, op: 'sub', answer: a - b, display: `${a} − ${b}` });
                    }
                }
            }
            
            if (state.operations.mul) {
                for (let a = 1; a <= 12; a++) {
                    for (let b = 1; b <= 12; b++) {
                        problems.push({ a, b, op: 'mul', answer: a * b, display: `${a} × ${b}` });
                    }
                }
            }
            
            if (state.operations.div) {
                for (let a = 1; a <= 12; a++) {
                    for (let b = 1; b <= 12; b++) {
                        const dividend = a * b;
                        problems.push({ a: dividend, b, op: 'div', answer: a, display: `${dividend} ÷ ${b}` });
                    }
                }
            }
            
            return problems;
        }
        
        function selectProblem() {
            const allProblems = generateAllProblems();
            if (allProblems.length === 0) return null;
            
            // Weight by difficulty
            const weighted = allProblems.map(p => {
                const key = p.display;
                const difficulty = getProblemDifficulty(key);
                return { problem: p, weight: 0.1 + difficulty };
            });
            
            const totalWeight = weighted.reduce((sum, w) => sum + w.weight, 0);
            let random = Math.random() * totalWeight;
            
            for (const w of weighted) {
                random -= w.weight;
                if (random <= 0) return w.problem;
            }
            
            return weighted[weighted.length - 1].problem;
        }
        
        function generateProblem() {
            const problem = selectProblem();
            if (!problem) {
                document.getElementById('problem').textContent = 'Enable at least one operation!';
                document.getElementById('answers').innerHTML = '';
                return;
            }
            
            state.currentProblem = problem;
            state.problemStartTime = Date.now();
            
            // Generate display based on mode
            let displayText;
            let correctAnswer;
            
            if (state.mode === 'answer') {
                displayText = `${problem.display} = ?`;
                correctAnswer = problem.answer;
            } else {
                // Question mode: hide one operand
                const opSymbol = { add: '+', sub: '−', mul: '×', div: '÷' }[problem.op];
                if (Math.random() < 0.5) {
                    displayText = `__ ${opSymbol} ${problem.b} = ${problem.answer}`;
                    correctAnswer = problem.a;
                } else {
                    displayText = `${problem.a} ${opSymbol} __ = ${problem.answer}`;
                    correctAnswer = problem.b;
                }
            }
            
            state.currentProblem.correctAnswer = correctAnswer;
            document.getElementById('problem').textContent = displayText;
            
            // Generate answer choices
            const choices = new Set([correctAnswer]);
            while (choices.size < state.numChoices) {
                let wrong;
                const variance = Math.max(5, Math.ceil(correctAnswer * 0.5));
                wrong = correctAnswer + Math.floor(Math.random() * variance * 2) - variance;
                if (wrong > 0 && wrong !== correctAnswer) {
                    choices.add(wrong);
                }
            }
            
            const shuffled = Array.from(choices).sort(() => Math.random() - 0.5);
            
            const answersDiv = document.getElementById('answers');
            answersDiv.innerHTML = '';
            
            for (const choice of shuffled) {
                const btn = document.createElement('button');
                btn.className = 'answer-btn';
                btn.textContent = choice;
                btn.addEventListener('click', () => submitAnswer(choice, btn));
                answersDiv.appendChild(btn);
            }
        }
        
        function submitAnswer(choice, btn) {
            const problem = state.currentProblem;
            if (!problem) return;
            
            const timeTaken = Date.now() - state.problemStartTime;
            const key = problem.display;
            
            if (!state.problems[key]) {
                state.problems[key] = { correct: 0, wrong: 0, totalTime: 0, attempts: 0 };
            }
            
            state.problems[key].attempts++;
            state.problems[key].totalTime += timeTaken;
            
            const isCorrect = choice === problem.correctAnswer;
            
            // Disable all buttons
            document.querySelectorAll('.answer-btn').forEach(b => b.disabled = true);
            
            if (isCorrect) {
                btn.classList.add('correct');
                state.problems[key].correct++;
                state.totalCorrect++;
                state.streak++;
                state.targetHeight = Math.min(CONFIG.GOAL_HEIGHT, state.targetHeight + 1);
                
                showFeedback('✓', '#4a8');
                createParticles(canvas.width / 2, state.characterY, '#4a8', 10);
                
                if (state.targetHeight >= CONFIG.GOAL_HEIGHT && !state.gameWon) {
                    state.gameWon = true;
                    saveState();
                    showVictory();
                    return;
                }
            } else {
                btn.classList.add('wrong');
                // Show correct answer
                document.querySelectorAll('.answer-btn').forEach(b => {
                    if (parseInt(b.textContent) === problem.correctAnswer) {
                        b.classList.add('correct');
                    }
                });
                
                state.problems[key].wrong++;
                state.totalWrong++;
                state.streak = 0;
                
                // Fall based on nerf level
                const fallPercent = Math.max(0, CONFIG.BASE_FALL_PERCENT - state.nerfLevel);
                const fallAmount = state.targetHeight * (fallPercent / 100);
                state.targetHeight = Math.max(0, state.targetHeight - fallAmount);
                
                state.nerfLevel = Math.min(100, state.nerfLevel + CONFIG.NERF_PER_FALL);
                
                showFeedback('✗', '#a44');
                createParticles(canvas.width / 2, state.characterY, '#a44', 20);
            }
            
            saveState();
            updateStats();
            
            setTimeout(() => {
                generateProblem();
            }, isCorrect ? 300 : 800);
        }
        
        function showFeedback(text, color) {
            const el = document.getElementById('feedback');
            el.textContent = text;
            el.style.color = color;
            el.style.opacity = '1';
            setTimeout(() => el.style.opacity = '0', 400);
        }

        // ========== BACKGROUND GAME ==========
        function generateStars() {
            state.stars = [];
            for (let i = 0; i < 100; i++) {
                state.stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 0.5 + 0.1,
                });
            }
        }
        
        function generatePlatforms() {
            state.platforms = [];
            const platformCount = CONFIG.GOAL_HEIGHT + 50;
            for (let i = 0; i < platformCount; i++) {
                state.platforms.push({
                    y: i,
                    x: 0.2 + Math.random() * 0.6,
                    width: 0.1 + Math.random() * 0.15,
                });
            }
        }
        
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                state.particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1,
                    color,
                });
            }
        }
        
        function getEnvironmentColors(height) {
            const progress = height / CONFIG.GOAL_HEIGHT;
            
            if (progress < 0.2) {
                // Deep underground - dark purple/black
                return { bg1: '#0a0510', bg2: '#15102a', platform: '#2a2040', accent: '#4a3060' };
            } else if (progress < 0.4) {
                // Caves - dark blue
                return { bg1: '#050a15', bg2: '#102030', platform: '#203040', accent: '#305060' };
            } else if (progress < 0.6) {
                // Surface - dark green/grey
                return { bg1: '#0a100a', bg2: '#152015', platform: '#253525', accent: '#354535' };
            } else if (progress < 0.8) {
                // Sky - dark blue with hints of purple
                return { bg1: '#0a0a20', bg2: '#151530', platform: '#252545', accent: '#404070' };
            } else {
                // Space - deep black with stars
                return { bg1: '#02020a', bg2: '#0a0a15', platform: '#202035', accent: '#4050a0' };
            }
        }
        
        function render() {
            // Smooth height animation
            state.height += (state.targetHeight - state.height) * 0.1;
            
            const colors = getEnvironmentColors(state.height);
            
            // Background gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, colors.bg1);
            gradient.addColorStop(1, colors.bg2);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Stars (more visible at higher altitudes)
            const starAlpha = Math.min(1, state.height / 500);
            for (const star of state.stars) {
                star.y += star.speed * (state.targetHeight > state.height ? -1 : state.targetHeight < state.height ? 1 : 0);
                if (star.y < 0) star.y = canvas.height;
                if (star.y > canvas.height) star.y = 0;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${starAlpha * (0.3 + Math.random() * 0.3)})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Platforms
            const visibleRange = 20;
            const baseY = canvas.height * 0.7;
            const platformSpacing = 30;
            
            for (let i = Math.max(0, Math.floor(state.height) - 5); i < Math.min(state.platforms.length, Math.floor(state.height) + visibleRange); i++) {
                const plat = state.platforms[i];
                const screenY = baseY - (i - state.height) * platformSpacing;
                
                if (screenY < -50 || screenY > canvas.height + 50) continue;
                
                const platX = plat.x * canvas.width;
                const platWidth = plat.width * canvas.width;
                
                ctx.fillStyle = colors.platform;
                ctx.fillRect(platX - platWidth / 2, screenY, platWidth, 8);
                
                // Platform glow
                ctx.fillStyle = colors.accent;
                ctx.fillRect(platX - platWidth / 2, screenY, platWidth, 2);
            }
            
            // Character
            const charX = canvas.width / 2;
            state.characterY = baseY - 20;
            
            // Character body
            ctx.fillStyle = '#8af';
            ctx.beginPath();
            ctx.arc(charX, state.characterY - 15, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Character glow
            const glowGradient = ctx.createRadialGradient(charX, state.characterY - 15, 0, charX, state.characterY - 15, 30);
            glowGradient.addColorStop(0, 'rgba(100, 180, 255, 0.3)');
            glowGradient.addColorStop(1, 'rgba(100, 180, 255, 0)');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(charX, state.characterY - 15, 30, 0, Math.PI * 2);
            ctx.fill();
            
            // Particles
            for (let i = state.particles.length - 1; i >= 0; i--) {
                const p = state.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.3;
                p.life -= 0.02;
                
                if (p.life <= 0) {
                    state.particles.splice(i, 1);
                    continue;
                }
                
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Height indicator on side
            const indicatorHeight = canvas.height * 0.6;
            const indicatorY = canvas.height * 0.2;
            const indicatorX = canvas.width - 30;
            
            ctx.fillStyle = 'rgba(30, 30, 50, 0.5)';
            ctx.fillRect(indicatorX - 5, indicatorY, 10, indicatorHeight);
            
            const progressHeight = (state.height / CONFIG.GOAL_HEIGHT) * indicatorHeight;
            ctx.fillStyle = '#4a8';
            ctx.fillRect(indicatorX - 5, indicatorY + indicatorHeight - progressHeight, 10, progressHeight);
            
            // Goal marker
            ctx.fillStyle = '#ff0';
            ctx.fillRect(indicatorX - 8, indicatorY - 2, 16, 4);
            
            requestAnimationFrame(render);
        }

        // ========== UI ==========
        function updateStats() {
            document.getElementById('heightDisplay').textContent = Math.floor(state.height);
            document.getElementById('streakDisplay').textContent = state.streak;
            document.getElementById('nerfDisplay').textContent = state.nerfLevel;
        }
        
        function updateMenuUI() {
            // Operations toggles
            document.querySelectorAll('.toggle[data-op]').forEach(toggle => {
                const op = toggle.dataset.op;
                toggle.classList.toggle('on', state.operations[op]);
            });
            
            // Mode buttons
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === state.mode);
            });
            
            // Choices slider
            document.getElementById('choicesSlider').value = state.numChoices;
            document.getElementById('choicesValue').textContent = state.numChoices;
            
            // Hardest problems
            updateHardestList();
            
            // Progress stats
            document.getElementById('progressStats').innerHTML = `
                <div style="color: #889; font-size: 13px; line-height: 1.8;">
                    Height: ${Math.floor(state.height)} / ${CONFIG.GOAL_HEIGHT}<br>
                    Total Correct: ${state.totalCorrect}<br>
                    Total Wrong: ${state.totalWrong}<br>
                    Accuracy: ${state.totalCorrect + state.totalWrong > 0 ? 
                        Math.round(state.totalCorrect / (state.totalCorrect + state.totalWrong) * 100) : 0}%<br>
                    Nerf Level: ${state.nerfLevel}%
                </div>
            `;
        }
        
        function updateHardestList() {
            const sorted = Object.entries(state.problems)
                .map(([key, data]) => ({
                    key,
                    difficulty: getProblemDifficulty(key),
                    ...data
                }))
                .sort((a, b) => b.difficulty - a.difficulty)
                .slice(0, 20);
            
            const listEl = document.getElementById('hardestList');
            if (sorted.length === 0) {
                listEl.innerHTML = '<div style="color: #556; font-size: 13px;">No data yet. Start playing!</div>';
                return;
            }
            
            listEl.innerHTML = sorted.map((p, i) => `
                <div class="hard-item">
                    <span class="problem-text">${i + 1}. ${p.key}</span>
                    <span class="stats-text">${p.correct}✓ ${p.wrong}✗ ${Math.round(p.totalTime / p.attempts / 100) / 10}s</span>
                </div>
            `).join('');
        }
        
        function openMenu() {
            updateMenuUI();
            document.getElementById('menu').classList.add('visible');
        }
        
        function closeMenu() {
            document.getElementById('menu').classList.remove('visible');
            generateProblem();
        }
        
        function showVictory() {
            document.getElementById('victoryStats').textContent = 
                `${state.totalCorrect} correct, ${state.totalWrong} wrong, ${state.nerfLevel}% nerf`;
            document.getElementById('victoryScreen').classList.add('visible');
        }

        // ========== EVENT LISTENERS ==========
        document.getElementById('menuBtn').addEventListener('click', openMenu);
        document.getElementById('closeMenu').addEventListener('click', closeMenu);
        document.getElementById('resumeBtn').addEventListener('click', closeMenu);
        document.getElementById('resetBtn').addEventListener('click', resetProgress);
        
        document.querySelectorAll('.toggle[data-op]').forEach(toggle => {
            toggle.addEventListener('click', () => {
                const op = toggle.dataset.op;
                state.operations[op] = !state.operations[op];
                toggle.classList.toggle('on', state.operations[op]);
                saveState();
            });
        });
        
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                state.mode = btn.dataset.mode;
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                saveState();
            });
        });
        
        document.getElementById('choicesSlider').addEventListener('input', (e) => {
            state.numChoices = parseInt(e.target.value);
            document.getElementById('choicesValue').textContent = state.numChoices;
            saveState();
        });
        
        document.getElementById('playAgainBtn').addEventListener('click', () => {
            state.height = 0;
            state.targetHeight = 0;
            state.gameWon = false;
            state.streak = 0;
            saveState();
            document.getElementById('victoryScreen').classList.remove('visible');
            generateProblem();
        });

        // ========== INIT ==========
        loadState();
        updateStats();
        generateProblem();
        render();
    </script>
</body>
</html>
