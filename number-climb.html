<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Number Climb</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #0a0a0f;
            font-family: 'Courier New', monospace;
            color: #aab;
            overflow: hidden;
            touch-action: manipulation;
            user-select: none;
        }
        
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            pointer-events: none;
        }
        
        #topBar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(10, 10, 20, 0.9);
            border-bottom: 1px solid #223;
            pointer-events: auto;
        }
        
        #stats {
            font-size: 12px;
            color: #889;
        }
        
        #menuBtn {
            background: rgba(40, 40, 60, 0.8);
            border: 1px solid #445;
            color: #aab;
            padding: 8px 16px;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        #menuBtn:hover {
            background: rgba(60, 60, 80, 0.9);
        }
        
        #problemArea {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            pointer-events: auto;
        }
        
        #problem {
            font-size: clamp(28px, 8vw, 48px);
            color: #eef;
            text-shadow: 0 0 20px rgba(150, 180, 255, 0.5), 0 2px 4px rgba(0,0,0,0.8);
            margin-bottom: 30px;
            text-align: center;
            background: rgba(10, 10, 25, 0.95);
            padding: 20px 40px;
            border-radius: 12px;
            border: 2px solid #446;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.1);
        }
        
        #answers {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 12px;
            max-width: 500px;
            width: 100%;
        }
        
        .answer-btn {
            background: linear-gradient(180deg, rgba(40, 40, 65, 0.95) 0%, rgba(25, 25, 45, 0.95) 100%);
            border: 2px solid #445;
            color: #dde;
            font-family: inherit;
            font-size: clamp(20px, 5vw, 28px);
            padding: 20px 10px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.15s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .answer-btn:hover {
            background: linear-gradient(180deg, rgba(55, 55, 85, 0.95) 0%, rgba(35, 35, 60, 0.95) 100%);
            border-color: #667;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.5);
        }
        
        .answer-btn:active {
            transform: scale(0.95) translateY(0);
        }
        
        .answer-btn.correct {
            background: linear-gradient(180deg, rgba(40, 140, 70, 0.95) 0%, rgba(25, 100, 45, 0.95) 100%);
            border-color: #4a8;
        }
        
        .answer-btn.wrong {
            background: linear-gradient(180deg, rgba(140, 40, 40, 0.95) 0%, rgba(100, 25, 25, 0.95) 100%);
            border-color: #a44;
        }
        
        #feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 64px;
            z-index: 20;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            text-shadow: 0 0 30px currentColor;
        }
        
        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 10, 0.97);
            z-index: 100;
            display: none;
            overflow-y: auto;
        }
        
        #menu.visible {
            display: block;
        }
        
        #menuContent {
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
        }
        
        #menu h2 {
            color: #aac;
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
            letter-spacing: 3px;
        }
        
        .menu-section {
            background: rgba(20, 20, 35, 0.8);
            border: 1px solid #334;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .menu-section h3 {
            color: #889;
            font-size: 14px;
            margin-bottom: 12px;
            letter-spacing: 2px;
        }
        
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #223;
        }
        
        .toggle-row:last-child {
            border-bottom: none;
        }
        
        .toggle-row label {
            color: #bbc;
            font-size: 16px;
        }
        
        .toggle {
            width: 50px;
            height: 28px;
            background: #333;
            border-radius: 14px;
            position: relative;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .toggle.on {
            background: #486;
        }
        
        .toggle::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: #ddd;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: left 0.2s;
        }
        
        .toggle.on::after {
            left: 25px;
        }
        
        .menu-btn {
            width: 100%;
            background: rgba(40, 40, 60, 0.8);
            border: 1px solid #445;
            color: #aab;
            padding: 12px;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            border-radius: 6px;
            margin-top: 10px;
        }
        
        .menu-btn:hover {
            background: rgba(60, 60, 80, 0.9);
        }
        
        .menu-btn.danger {
            border-color: #644;
            color: #c99;
        }
        
        .menu-btn.danger:hover {
            background: rgba(80, 40, 40, 0.9);
        }
        
        #hardestList {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .hard-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #223;
            font-size: 13px;
        }
        
        .hard-item .problem-text {
            color: #bbc;
        }
        
        .hard-item .stats-text {
            color: #778;
        }
        
        .slider-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
        }
        
        .slider-row input[type="range"] {
            width: 120px;
        }
        
        .slider-value {
            color: #8af;
            min-width: 30px;
            text-align: right;
        }
        
        #modeToggle {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 12px;
            background: rgba(30, 30, 50, 0.8);
            border: 1px solid #445;
            color: #889;
            font-family: inherit;
            font-size: 13px;
            cursor: pointer;
            border-radius: 6px;
        }
        
        .mode-btn.active {
            background: rgba(60, 80, 100, 0.9);
            border-color: #68a;
            color: #bdf;
        }
        
        #closeMenu {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(60, 40, 40, 0.8);
            border: 1px solid #644;
            color: #c99;
            width: 40px;
            height: 40px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 50%;
            z-index: 101;
        }
        
        #victoryScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 20, 30, 0.95);
            z-index: 200;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        
        #victoryScreen.visible {
            display: flex;
        }
        
        #victoryScreen h1 {
            font-size: 36px;
            color: #8cf;
            letter-spacing: 5px;
            margin-bottom: 20px;
        }
        
        #victoryScreen p {
            color: #889;
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="topBar">
            <div id="stats">
                <div>Height: <span id="heightDisplay">0</span> / 1000</div>
                <div>Streak: <span id="streakDisplay">0</span> | Karma: <span id="karmaDisplay">0</span>%</div>
            </div>
            <button id="menuBtn">☰ Menu</button>
        </div>
        
        <div id="problemArea">
            <div id="problem">7 × 8 = ?</div>
            <div id="answers"></div>
        </div>
    </div>
    
    <div id="feedback"></div>
    
    <div id="menu">
        <button id="closeMenu">×</button>
        <div id="menuContent">
            <h2>NUMBER CLIMB</h2>
            
            <div class="menu-section">
                <h3>OPERATIONS</h3>
                <div class="toggle-row">
                    <label>Addition (+)</label>
                    <div class="toggle on" data-op="add"></div>
                </div>
                <div class="toggle-row">
                    <label>Subtraction (−)</label>
                    <div class="toggle on" data-op="sub"></div>
                </div>
                <div class="toggle-row">
                    <label>Multiplication (×)</label>
                    <div class="toggle on" data-op="mul"></div>
                </div>
                <div class="toggle-row">
                    <label>Division (÷)</label>
                    <div class="toggle on" data-op="div"></div>
                </div>
            </div>
            
            <div class="menu-section">
                <h3>GAME MODE</h3>
                <div id="modeToggle">
                    <button class="mode-btn active" data-mode="answer">Answer Mode</button>
                    <button class="mode-btn" data-mode="question">Question Mode</button>
                </div>
            </div>
            
            <div class="menu-section">
                <h3>OPTIONS</h3>
                <div class="slider-row">
                    <label>Answer Choices</label>
                    <input type="range" id="choicesSlider" min="4" max="8" value="6">
                    <span class="slider-value" id="choicesValue">6</span>
                </div>
            </div>
            
            <div class="menu-section">
                <h3>TOP 20 HARDEST</h3>
                <div id="hardestList"></div>
            </div>
            
            <div class="menu-section">
                <h3>PROGRESS</h3>
                <div id="progressStats"></div>
                <button class="menu-btn danger" id="resetBtn">Reset All Progress</button>
            </div>
            
            <button class="menu-btn" id="resumeBtn">Resume Game</button>
        </div>
    </div>
    
    <div id="victoryScreen">
        <h1>ASCENSION COMPLETE</h1>
        <p>You've conquered the Number Climb.</p>
        <p id="victoryStats"></p>
        <button class="menu-btn" id="playAgainBtn">Climb Again</button>
    </div>

    <script>
        // ========== CONFIGURATION ==========
        const CONFIG = {
            GOAL_HEIGHT: 1000,
            KARMA_PER_CORRECT: 10, // Every 10 correct = 1% karma
        };

        // ========== CANVAS SETUP ==========
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ========== GAME STATE ==========
        let state = {
            height: 0,
            targetHeight: 0,
            streak: 0,
            karmaLevel: 0,
            totalCorrect: 0,
            totalWrong: 0,
            operations: { add: true, sub: true, mul: true, div: true },
            mode: 'answer',
            numChoices: 6,
            problems: {},
            currentProblem: null,
            problemStartTime: 0,
            gameWon: false,
            characterY: 0,
            characterVY: 0,
            characterState: 'idle', // idle, jumping, falling
            animFrame: 0,
            platforms: [],
            particles: [],
            stars: [],
            clouds: [],
            time: 0,
        };

        // ========== STORAGE ==========
        function saveState() {
            const saveData = {
                height: state.height,
                karmaLevel: state.karmaLevel,
                totalCorrect: state.totalCorrect,
                totalWrong: state.totalWrong,
                operations: state.operations,
                mode: state.mode,
                numChoices: state.numChoices,
                problems: state.problems,
                gameWon: state.gameWon,
            };
            localStorage.setItem('numberClimb', JSON.stringify(saveData));
        }
        
        function loadState() {
            const saved = localStorage.getItem('numberClimb');
            if (saved) {
                const data = JSON.parse(saved);
                // Handle migration from old nerfLevel to karmaLevel
                if (data.nerfLevel !== undefined && data.karmaLevel === undefined) {
                    data.karmaLevel = Math.floor(data.totalCorrect / CONFIG.KARMA_PER_CORRECT);
                    delete data.nerfLevel;
                }
                Object.assign(state, data);
                state.targetHeight = state.height;
                // Recalculate karma from totalCorrect for consistency
                state.karmaLevel = Math.min(100, Math.floor(state.totalCorrect / CONFIG.KARMA_PER_CORRECT));
            }
            generateStars();
            generateClouds();
            generatePlatforms();
        }
        
        function resetProgress() {
            if (confirm('Reset all progress? This cannot be undone.')) {
                localStorage.removeItem('numberClimb');
                state = {
                    height: 0,
                    targetHeight: 0,
                    streak: 0,
                    karmaLevel: 0,
                    totalCorrect: 0,
                    totalWrong: 0,
                    operations: { add: true, sub: true, mul: true, div: true },
                    mode: 'answer',
                    numChoices: 6,
                    problems: {},
                    currentProblem: null,
                    problemStartTime: 0,
                    gameWon: false,
                    characterY: 0,
                    characterVY: 0,
                    characterState: 'idle',
                    animFrame: 0,
                    platforms: [],
                    particles: [],
                    stars: [],
                    clouds: [],
                    time: 0,
                };
                generateStars();
                generateClouds();
                generatePlatforms();
                updateMenuUI();
                generateProblem();
                closeMenu();
            }
        }

        // ========== PROBLEM GENERATION ==========
        function getProblemDifficulty(key) {
            const p = state.problems[key];
            if (!p || p.attempts === 0) return 0.5;
            const avgTime = p.totalTime / p.attempts;
            const errorRate = p.wrong / p.attempts;
            return (avgTime / 5000) + (errorRate * 2);
        }
        
        function generateAllProblems() {
            const problems = [];
            
            if (state.operations.add) {
                for (let a = 1; a <= 12; a++) {
                    for (let b = 1; b <= 12; b++) {
                        problems.push({ a, b, op: 'add', answer: a + b, display: `${a} + ${b}` });
                    }
                }
            }
            
            if (state.operations.sub) {
                for (let a = 2; a <= 20; a++) {
                    for (let b = 1; b < a; b++) {
                        problems.push({ a, b, op: 'sub', answer: a - b, display: `${a} − ${b}` });
                    }
                }
            }
            
            if (state.operations.mul) {
                for (let a = 1; a <= 12; a++) {
                    for (let b = 1; b <= 12; b++) {
                        problems.push({ a, b, op: 'mul', answer: a * b, display: `${a} × ${b}` });
                    }
                }
            }
            
            if (state.operations.div) {
                for (let a = 1; a <= 12; a++) {
                    for (let b = 1; b <= 12; b++) {
                        const dividend = a * b;
                        problems.push({ a: dividend, b, op: 'div', answer: a, display: `${dividend} ÷ ${b}` });
                    }
                }
            }
            
            return problems;
        }
        
        function selectProblem() {
            const allProblems = generateAllProblems();
            if (allProblems.length === 0) return null;
            
            const weighted = allProblems.map(p => {
                const key = p.display;
                const difficulty = getProblemDifficulty(key);
                return { problem: p, weight: 0.1 + difficulty };
            });
            
            const totalWeight = weighted.reduce((sum, w) => sum + w.weight, 0);
            let random = Math.random() * totalWeight;
            
            for (const w of weighted) {
                random -= w.weight;
                if (random <= 0) return w.problem;
            }
            
            return weighted[weighted.length - 1].problem;
        }
        
        function generateProblem() {
            const problem = selectProblem();
            if (!problem) {
                document.getElementById('problem').textContent = 'Enable at least one operation!';
                document.getElementById('answers').innerHTML = '';
                return;
            }
            
            state.currentProblem = problem;
            state.problemStartTime = Date.now();
            
            let displayText;
            let correctAnswer;
            
            if (state.mode === 'answer') {
                displayText = `${problem.display} = ?`;
                correctAnswer = problem.answer;
            } else {
                const opSymbol = { add: '+', sub: '−', mul: '×', div: '÷' }[problem.op];
                if (Math.random() < 0.5) {
                    displayText = `__ ${opSymbol} ${problem.b} = ${problem.answer}`;
                    correctAnswer = problem.a;
                } else {
                    displayText = `${problem.a} ${opSymbol} __ = ${problem.answer}`;
                    correctAnswer = problem.b;
                }
            }
            
            state.currentProblem.correctAnswer = correctAnswer;
            document.getElementById('problem').textContent = displayText;
            
            const choices = new Set([correctAnswer]);
            while (choices.size < state.numChoices) {
                const variance = Math.max(5, Math.ceil(correctAnswer * 0.5));
                const wrong = correctAnswer + Math.floor(Math.random() * variance * 2) - variance;
                if (wrong > 0 && wrong !== correctAnswer) {
                    choices.add(wrong);
                }
            }
            
            const shuffled = Array.from(choices).sort(() => Math.random() - 0.5);
            
            const answersDiv = document.getElementById('answers');
            answersDiv.innerHTML = '';
            
            for (const choice of shuffled) {
                const btn = document.createElement('button');
                btn.className = 'answer-btn';
                btn.textContent = choice;
                btn.addEventListener('click', () => submitAnswer(choice, btn));
                answersDiv.appendChild(btn);
            }
        }
        
        function submitAnswer(choice, btn) {
            const problem = state.currentProblem;
            if (!problem) return;
            
            const timeTaken = Date.now() - state.problemStartTime;
            const key = problem.display;
            
            if (!state.problems[key]) {
                state.problems[key] = { correct: 0, wrong: 0, totalTime: 0, attempts: 0 };
            }
            
            state.problems[key].attempts++;
            state.problems[key].totalTime += timeTaken;
            
            const isCorrect = choice === problem.correctAnswer;
            
            document.querySelectorAll('.answer-btn').forEach(b => b.disabled = true);
            
            if (isCorrect) {
                btn.classList.add('correct');
                state.problems[key].correct++;
                state.totalCorrect++;
                state.streak++;
                state.targetHeight = Math.min(CONFIG.GOAL_HEIGHT, state.targetHeight + 1);
                
                // Karma increases by 1% every 10 correct answers
                state.karmaLevel = Math.min(100, Math.floor(state.totalCorrect / CONFIG.KARMA_PER_CORRECT));
                
                state.characterState = 'jumping';
                state.characterVY = -15;
                
                showFeedback('✓', '#4a8');
                createParticles(canvas.width / 2, state.characterY, '#4a8', 15);
                
                if (state.targetHeight >= CONFIG.GOAL_HEIGHT && !state.gameWon) {
                    state.gameWon = true;
                    saveState();
                    showVictory();
                    return;
                }
            } else {
                btn.classList.add('wrong');
                document.querySelectorAll('.answer-btn').forEach(b => {
                    if (parseInt(b.textContent) === problem.correctAnswer) {
                        b.classList.add('correct');
                    }
                });
                
                state.problems[key].wrong++;
                state.totalWrong++;
                state.streak = 0;
                
                // Fall based on karma level (0 karma = 100% fall, 100 karma = 0% fall)
                const fallPercent = Math.max(0, 100 - state.karmaLevel);
                const fallAmount = state.targetHeight * (fallPercent / 100);
                state.targetHeight = Math.max(0, state.targetHeight - fallAmount);
                
                state.characterState = 'falling';
                state.characterVY = 5;
                
                showFeedback('✗', '#a44');
                createParticles(canvas.width / 2, state.characterY, '#a44', 25);
            }
            
            saveState();
            updateStats();
            
            setTimeout(() => {
                generateProblem();
            }, isCorrect ? 300 : 800);
        }
        
        function showFeedback(text, color) {
            const el = document.getElementById('feedback');
            el.textContent = text;
            el.style.color = color;
            el.style.opacity = '1';
            setTimeout(() => el.style.opacity = '0', 400);
        }

        // ========== BACKGROUND GAME ==========
        function generateStars() {
            state.stars = [];
            for (let i = 0; i < 150; i++) {
                state.stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    twinkle: Math.random() * Math.PI * 2,
                    speed: Math.random() * 0.3 + 0.1,
                });
            }
        }
        
        function generateClouds() {
            state.clouds = [];
            for (let i = 0; i < 20; i++) {
                state.clouds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * 2000,
                    width: 100 + Math.random() * 200,
                    height: 40 + Math.random() * 60,
                    speed: 0.2 + Math.random() * 0.3,
                });
            }
        }
        
        function generatePlatforms() {
            state.platforms = [];
            const platformCount = CONFIG.GOAL_HEIGHT + 50;
            for (let i = 0; i < platformCount; i++) {
                const variation = Math.sin(i * 0.1) * 0.2;
                state.platforms.push({
                    y: i,
                    x: 0.3 + variation + Math.random() * 0.4,
                    width: 0.12 + Math.random() * 0.1,
                    type: Math.floor(Math.random() * 3),
                });
            }
        }
        
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                const speed = 3 + Math.random() * 6;
                state.particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 3,
                    life: 1,
                    color,
                    size: 2 + Math.random() * 4,
                });
            }
        }
        
        function getEnvironmentColors(height) {
            const progress = height / CONFIG.GOAL_HEIGHT;
            
            if (progress < 0.15) {
                return { 
                    bg1: '#0a0510', bg2: '#1a1025', 
                    platform: '#3a2850', platformTop: '#5a3870', platformGlow: '#8040a0',
                    accent: '#6030a0', name: 'The Depths'
                };
            } else if (progress < 0.35) {
                return { 
                    bg1: '#05080f', bg2: '#101828', 
                    platform: '#203848', platformTop: '#305868', platformGlow: '#4080a0',
                    accent: '#2060a0', name: 'Crystal Caves'
                };
            } else if (progress < 0.55) {
                return { 
                    bg1: '#080a05', bg2: '#152010', 
                    platform: '#2a3820', platformTop: '#3a4830', platformGlow: '#5a8040',
                    accent: '#408030', name: 'The Surface'
                };
            } else if (progress < 0.75) {
                return { 
                    bg1: '#08080f', bg2: '#181830', 
                    platform: '#303050', platformTop: '#404068', platformGlow: '#6060a0',
                    accent: '#5050a0', name: 'Sky Realm'
                };
            } else {
                return { 
                    bg1: '#020208', bg2: '#0a0a18', 
                    platform: '#252540', platformTop: '#353560', platformGlow: '#5050ff',
                    accent: '#4040c0', name: 'The Void'
                };
            }
        }
        
        function drawPlatform(x, y, width, colors, type) {
            const h = 12;
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.ellipse(x, y + h + 4, width * 0.45, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Platform body (3D effect)
            ctx.fillStyle = colors.platform;
            ctx.beginPath();
            ctx.moveTo(x - width/2, y);
            ctx.lineTo(x + width/2, y);
            ctx.lineTo(x + width/2 - 4, y + h);
            ctx.lineTo(x - width/2 + 4, y + h);
            ctx.closePath();
            ctx.fill();
            
            // Platform top
            ctx.fillStyle = colors.platformTop;
            ctx.beginPath();
            ctx.ellipse(x, y, width/2, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.beginPath();
            ctx.ellipse(x, y - 2, width/2 - 4, 4, 0, Math.PI, Math.PI * 2);
            ctx.fill();
            
            // Glow underneath
            const glow = ctx.createRadialGradient(x, y + h/2, 0, x, y + h/2, width/2);
            glow.addColorStop(0, colors.platformGlow + '40');
            glow.addColorStop(1, 'transparent');
            ctx.fillStyle = glow;
            ctx.fillRect(x - width/2, y - 10, width, h + 20);
            
            // Crystal/decoration based on type
            if (type === 1) {
                ctx.fillStyle = colors.platformGlow;
                ctx.beginPath();
                ctx.moveTo(x, y - 15);
                ctx.lineTo(x + 4, y - 4);
                ctx.lineTo(x - 4, y - 4);
                ctx.closePath();
                ctx.fill();
            } else if (type === 2) {
                ctx.fillStyle = colors.accent + '80';
                ctx.beginPath();
                ctx.arc(x - 10, y - 3, 3, 0, Math.PI * 2);
                ctx.arc(x + 10, y - 3, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawCharacter(x, y, state_name) {
            const bounce = Math.sin(state.time * 8) * 2;
            const t = state.time;
            
            ctx.save();
            ctx.translate(x, y);
            
            // Glow aura
            const auraGrad = ctx.createRadialGradient(0, -20, 0, 0, -20, 50);
            auraGrad.addColorStop(0, 'rgba(100, 180, 255, 0.3)');
            auraGrad.addColorStop(0.5, 'rgba(100, 180, 255, 0.1)');
            auraGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = auraGrad;
            ctx.beginPath();
            ctx.arc(0, -20, 50, 0, Math.PI * 2);
            ctx.fill();
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 0, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Legs
            const legSwing = state_name === 'jumping' ? -0.3 : state_name === 'falling' ? 0.5 : Math.sin(t * 5) * 0.1;
            ctx.strokeStyle = '#68c';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            
            // Left leg
            ctx.beginPath();
            ctx.moveTo(-5, -12 + bounce);
            ctx.lineTo(-8, 0);
            ctx.stroke();
            
            // Right leg
            ctx.beginPath();
            ctx.moveTo(5, -12 + bounce);
            ctx.lineTo(8, 0);
            ctx.stroke();
            
            // Body
            ctx.fillStyle = '#5af';
            ctx.beginPath();
            ctx.ellipse(0, -22 + bounce, 10, 14, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Body highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.ellipse(-3, -26 + bounce, 4, 6, -0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Head
            ctx.fillStyle = '#8cf';
            ctx.beginPath();
            ctx.arc(0, -40 + bounce, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Head highlight
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath();
            ctx.arc(-3, -43 + bounce, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-4, -40 + bounce, 2.5, 0, Math.PI * 2);
            ctx.arc(4, -40 + bounce, 2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Pupils
            ctx.fillStyle = '#224';
            ctx.beginPath();
            ctx.arc(-3.5, -40 + bounce, 1.5, 0, Math.PI * 2);
            ctx.arc(4.5, -40 + bounce, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Arms
            ctx.strokeStyle = '#68c';
            ctx.lineWidth = 4;
            
            const armRaise = state_name === 'jumping' ? -0.8 : state_name === 'falling' ? 0.5 : 0;
            
            // Left arm
            ctx.beginPath();
            ctx.moveTo(-10, -25 + bounce);
            ctx.lineTo(-18, -18 + bounce + armRaise * 15);
            ctx.stroke();
            
            // Right arm
            ctx.beginPath();
            ctx.moveTo(10, -25 + bounce);
            ctx.lineTo(18, -18 + bounce + armRaise * 15);
            ctx.stroke();
            
            // Cape/trail effect when moving
            if (state_name === 'jumping' || state_name === 'falling') {
                ctx.fillStyle = 'rgba(100, 150, 255, 0.3)';
                ctx.beginPath();
                ctx.moveTo(-8, -15 + bounce);
                ctx.quadraticCurveTo(0, 20, 8, -15 + bounce);
                ctx.quadraticCurveTo(0, -5, -8, -15 + bounce);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function render() {
            state.time += 0.016;
            state.animFrame++;
            
            // Smooth height animation
            const heightDiff = state.targetHeight - state.height;
            state.height += heightDiff * 0.08;
            
            // Update character physics
            if (state.characterState === 'jumping') {
                state.characterVY += 0.8;
                if (state.characterVY > 0) {
                    state.characterState = 'idle';
                }
            } else if (state.characterState === 'falling') {
                state.characterVY *= 0.95;
                if (Math.abs(heightDiff) < 1) {
                    state.characterState = 'idle';
                    state.characterVY = 0;
                }
            }
            
            const colors = getEnvironmentColors(state.height);
            
            // Background gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, colors.bg1);
            gradient.addColorStop(1, colors.bg2);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Stars (more visible at higher altitudes)
            const starAlpha = Math.min(1, state.height / 400);
            for (const star of state.stars) {
                const parallax = (state.targetHeight - state.height) * star.speed;
                star.y += parallax * 0.5;
                if (star.y < 0) star.y = canvas.height;
                if (star.y > canvas.height) star.y = 0;
                
                const twinkle = Math.sin(state.time * 3 + star.twinkle) * 0.3 + 0.7;
                ctx.fillStyle = `rgba(255, 255, 255, ${starAlpha * twinkle * 0.8})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Clouds (only in mid sections)
            if (state.height > 300 && state.height < 800) {
                const cloudAlpha = 1 - Math.abs(state.height - 550) / 300;
                for (const cloud of state.clouds) {
                    const screenY = (cloud.y - state.height * 2) % (canvas.height + 200) - 100;
                    cloud.x += cloud.speed;
                    if (cloud.x > canvas.width + cloud.width) cloud.x = -cloud.width;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${cloudAlpha * 0.08})`;
                    ctx.beginPath();
                    ctx.ellipse(cloud.x, screenY, cloud.width/2, cloud.height/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Platforms
            const visibleRange = 25;
            const baseY = canvas.height * 0.65;
            const platformSpacing = 28;
            
            for (let i = Math.max(0, Math.floor(state.height) - 8); i < Math.min(state.platforms.length, Math.floor(state.height) + visibleRange); i++) {
                const plat = state.platforms[i];
                const screenY = baseY - (i - state.height) * platformSpacing;
                
                if (screenY < -50 || screenY > canvas.height + 50) continue;
                
                const platX = plat.x * canvas.width;
                const platWidth = plat.width * canvas.width;
                
                drawPlatform(platX, screenY, platWidth, colors, plat.type);
            }
            
            // Character
            const charX = canvas.width / 2;
            state.characterY = baseY - 20 + state.characterVY;
            
            drawCharacter(charX, state.characterY, state.characterState);
            
            // Particles
            for (let i = state.particles.length - 1; i >= 0; i--) {
                const p = state.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.vx *= 0.98;
                p.life -= 0.015;
                
                if (p.life <= 0) {
                    state.particles.splice(i, 1);
                    continue;
                }
                
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Height indicator
            const indicatorHeight = canvas.height * 0.5;
            const indicatorY = canvas.height * 0.25;
            const indicatorX = canvas.width - 25;
            
            // Track background
            ctx.fillStyle = 'rgba(30, 30, 50, 0.6)';
            ctx.beginPath();
            ctx.roundRect(indicatorX - 6, indicatorY, 12, indicatorHeight, 6);
            ctx.fill();
            
            // Progress fill
            const progressHeight = (state.height / CONFIG.GOAL_HEIGHT) * indicatorHeight;
            const progGrad = ctx.createLinearGradient(0, indicatorY + indicatorHeight, 0, indicatorY);
            progGrad.addColorStop(0, '#2a4');
            progGrad.addColorStop(0.5, '#4c8');
            progGrad.addColorStop(1, '#8ef');
            ctx.fillStyle = progGrad;
            ctx.beginPath();
            ctx.roundRect(indicatorX - 4, indicatorY + indicatorHeight - progressHeight, 8, progressHeight, 4);
            ctx.fill();
            
            // Goal marker
            ctx.fillStyle = '#ff0';
            ctx.shadowColor = '#ff0';
            ctx.shadowBlur = 10;
            ctx.fillRect(indicatorX - 10, indicatorY - 2, 20, 4);
            ctx.shadowBlur = 0;
            
            // Zone name
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.font = '12px monospace';
            ctx.textAlign = 'right';
            ctx.fillText(colors.name, canvas.width - 15, canvas.height - 15);
            
            requestAnimationFrame(render);
        }

        // ========== UI ==========
        function updateStats() {
            document.getElementById('heightDisplay').textContent = Math.floor(state.height);
            document.getElementById('streakDisplay').textContent = state.streak;
            document.getElementById('karmaDisplay').textContent = state.karmaLevel;
        }
        
        function updateMenuUI() {
            document.querySelectorAll('.toggle[data-op]').forEach(toggle => {
                const op = toggle.dataset.op;
                toggle.classList.toggle('on', state.operations[op]);
            });
            
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === state.mode);
            });
            
            document.getElementById('choicesSlider').value = state.numChoices;
            document.getElementById('choicesValue').textContent = state.numChoices;
            
            updateHardestList();
            
            document.getElementById('progressStats').innerHTML = `
                <div style="color: #889; font-size: 13px; line-height: 1.8;">
                    Height: ${Math.floor(state.height)} / ${CONFIG.GOAL_HEIGHT}<br>
                    Total Correct: ${state.totalCorrect}<br>
                    Total Wrong: ${state.totalWrong}<br>
                    Accuracy: ${state.totalCorrect + state.totalWrong > 0 ? 
                        Math.round(state.totalCorrect / (state.totalCorrect + state.totalWrong) * 100) : 0}%<br>
                    Karma Level: ${state.karmaLevel}% (${state.totalCorrect % CONFIG.KARMA_PER_CORRECT}/${CONFIG.KARMA_PER_CORRECT} to next)
                </div>
            `;
        }
        
        function updateHardestList() {
            const sorted = Object.entries(state.problems)
                .map(([key, data]) => ({
                    key,
                    difficulty: getProblemDifficulty(key),
                    ...data
                }))
                .sort((a, b) => b.difficulty - a.difficulty)
                .slice(0, 20);
            
            const listEl = document.getElementById('hardestList');
            if (sorted.length === 0) {
                listEl.innerHTML = '<div style="color: #556; font-size: 13px;">No data yet. Start playing!</div>';
                return;
            }
            
            listEl.innerHTML = sorted.map((p, i) => `
                <div class="hard-item">
                    <span class="problem-text">${i + 1}. ${p.key}</span>
                    <span class="stats-text">${p.correct}✓ ${p.wrong}✗ ${Math.round(p.totalTime / p.attempts / 100) / 10}s</span>
                </div>
            `).join('');
        }
        
        function openMenu() {
            updateMenuUI();
            document.getElementById('menu').classList.add('visible');
        }
        
        function closeMenu() {
            document.getElementById('menu').classList.remove('visible');
            generateProblem();
        }
        
        function showVictory() {
            document.getElementById('victoryStats').textContent = 
                `${state.totalCorrect} correct, ${state.totalWrong} wrong, ${state.karmaLevel}% karma`;
            document.getElementById('victoryScreen').classList.add('visible');
        }

        // ========== EVENT LISTENERS ==========
        document.getElementById('menuBtn').addEventListener('click', openMenu);
        document.getElementById('closeMenu').addEventListener('click', closeMenu);
        document.getElementById('resumeBtn').addEventListener('click', closeMenu);
        document.getElementById('resetBtn').addEventListener('click', resetProgress);
        
        document.querySelectorAll('.toggle[data-op]').forEach(toggle => {
            toggle.addEventListener('click', () => {
                const op = toggle.dataset.op;
                state.operations[op] = !state.operations[op];
                toggle.classList.toggle('on', state.operations[op]);
                saveState();
            });
        });
        
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                state.mode = btn.dataset.mode;
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                saveState();
            });
        });
        
        document.getElementById('choicesSlider').addEventListener('input', (e) => {
            state.numChoices = parseInt(e.target.value);
            document.getElementById('choicesValue').textContent = state.numChoices;
            saveState();
        });
        
        document.getElementById('playAgainBtn').addEventListener('click', () => {
            state.height = 0;
            state.targetHeight = 0;
            state.gameWon = false;
            state.streak = 0;
            saveState();
            document.getElementById('victoryScreen').classList.remove('visible');
            generateProblem();
        });

        // ========== INIT ==========
        loadState();
        updateStats();
        generateProblem();
        render();
    </script>
</body>
</html>
